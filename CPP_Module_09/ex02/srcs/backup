void PmergeMe::dequeMergeInsertSort() {
	// Base case
	if (_container1.size() <= 1) {
		return;
	}

	// Split the list into pairs
	std::deque< std::deque<int> >pairs;
	for (size_t i = 0; i < _container1.size(); i += 2) {
		std::deque<int> pair;
		pair.push_back(_container1[i]);
		if (i + 1 < _container1.size()) {
			pair.push_back(_container1[i + 1]);
		}
		pairs.push_back(pair);
	}

	// Sort the pairs based on their first element
	for (size_t i = 0; i < pairs.size(); i++) {
		for (size_t j = i + 1; j < pairs.size(); j++) {
			if (pairs[i].front() > pairs[j].front()) {
				swap(pairs[i], pairs[j]);
			}
		}
	}

	// Create the main-chain by taking the first element of each pair
	std::deque<int> mainChain;
	for (size_t i = 0; i < pairs.size(); i++) {
		mainChain.push_back(pairs[i].front());
	}

	// Insert the remaining elements into the main-chain
	std::deque<int>::iterator it;
	for (size_t i = 0; i < pairs.size(); i++) {
		for (size_t j = 1; j < pairs[i].size(); j++) {
			int b = pairs[i][j];

			// Determine the insertion point using binary search
			it = lower_bound(mainChain.begin(), mainChain.begin() + i + 1, b);

			// Calculate the worst-case cost for binary search insertion
			int n = distance(mainChain.begin(), it) + 1;
			int log2n = static_cast<int>(floor(log2(n)));

			// Find the Jacobsthal number for the current position
			int k = i - (n - (1 << log2n));

			// Follow the Jacobsthal number sequence to determine the insertion position
			while (k > 0) {
				int j = (k % 2 == 0) ? 2 : 1;
				k = (k - j) / 2;
				it++;
			}

			// Insert the element
			mainChain.insert(it, b);
		}
	}

	// Update the original list
	_container1 = mainChain;
}